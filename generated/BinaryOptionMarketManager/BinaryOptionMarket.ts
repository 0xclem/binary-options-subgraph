// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class Bid extends ethereum.Event {
  get params(): Bid__Params {
    return new Bid__Params(this);
  }
}

export class Bid__Params {
  _event: Bid;

  constructor(event: Bid) {
    this._event = event;
  }

  get side(): i32 {
    return this._event.parameters[0].value.toI32();
  }

  get account(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get value(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class MarketResolved extends ethereum.Event {
  get params(): MarketResolved__Params {
    return new MarketResolved__Params(this);
  }
}

export class MarketResolved__Params {
  _event: MarketResolved;

  constructor(event: MarketResolved) {
    this._event = event;
  }

  get result(): i32 {
    return this._event.parameters[0].value.toI32();
  }

  get oraclePrice(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get oracleTimestamp(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get deposited(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get poolFees(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get creatorFees(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }
}

export class OptionsClaimed extends ethereum.Event {
  get params(): OptionsClaimed__Params {
    return new OptionsClaimed__Params(this);
  }
}

export class OptionsClaimed__Params {
  _event: OptionsClaimed;

  constructor(event: OptionsClaimed) {
    this._event = event;
  }

  get account(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get longOptions(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get shortOptions(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class OptionsExercised extends ethereum.Event {
  get params(): OptionsExercised__Params {
    return new OptionsExercised__Params(this);
  }
}

export class OptionsExercised__Params {
  _event: OptionsExercised;

  constructor(event: OptionsExercised) {
    this._event = event;
  }

  get account(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get value(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class OwnerChanged extends ethereum.Event {
  get params(): OwnerChanged__Params {
    return new OwnerChanged__Params(this);
  }
}

export class OwnerChanged__Params {
  _event: OwnerChanged;

  constructor(event: OwnerChanged) {
    this._event = event;
  }

  get oldOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class OwnerNominated extends ethereum.Event {
  get params(): OwnerNominated__Params {
    return new OwnerNominated__Params(this);
  }
}

export class OwnerNominated__Params {
  _event: OwnerNominated;

  constructor(event: OwnerNominated) {
    this._event = event;
  }

  get newOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class PricesUpdated extends ethereum.Event {
  get params(): PricesUpdated__Params {
    return new PricesUpdated__Params(this);
  }
}

export class PricesUpdated__Params {
  _event: PricesUpdated;

  constructor(event: PricesUpdated) {
    this._event = event;
  }

  get longPrice(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get shortPrice(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class Refund extends ethereum.Event {
  get params(): Refund__Params {
    return new Refund__Params(this);
  }
}

export class Refund__Params {
  _event: Refund;

  constructor(event: Refund) {
    this._event = event;
  }

  get side(): i32 {
    return this._event.parameters[0].value.toI32();
  }

  get account(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get value(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get fee(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class BinaryOptionMarket__balancesOfResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class BinaryOptionMarket__bidsOfResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class BinaryOptionMarket__claimOptionsResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class BinaryOptionMarket__claimableBalancesOfResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class BinaryOptionMarket__creatorLimitsResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class BinaryOptionMarket__feesResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }
}

export class BinaryOptionMarket__optionsResult {
  value0: Address;
  value1: Address;

  constructor(value0: Address, value1: Address) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddress(this.value0));
    map.set("value1", ethereum.Value.fromAddress(this.value1));
    return map;
  }
}

export class BinaryOptionMarket__oracleDetailsResult {
  value0: Bytes;
  value1: BigInt;
  value2: BigInt;

  constructor(value0: Bytes, value1: BigInt, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromFixedBytes(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }
}

export class BinaryOptionMarket__oraclePriceAndTimestampResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class BinaryOptionMarket__pricesResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class BinaryOptionMarket__pricesAfterBidOrRefundResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class BinaryOptionMarket__senderPriceAndExercisableDepositsResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class BinaryOptionMarket__timesResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }
}

export class BinaryOptionMarket__totalBidsResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class BinaryOptionMarket__totalClaimableSuppliesResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class BinaryOptionMarket__totalSuppliesResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class BinaryOptionMarket extends ethereum.SmartContract {
  static bind(address: Address): BinaryOptionMarket {
    return new BinaryOptionMarket("BinaryOptionMarket", address);
  }

  MAX_ADDRESSES_FROM_RESOLVER(): BigInt {
    let result = super.call(
      "MAX_ADDRESSES_FROM_RESOLVER",
      "MAX_ADDRESSES_FROM_RESOLVER():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_MAX_ADDRESSES_FROM_RESOLVER(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "MAX_ADDRESSES_FROM_RESOLVER",
      "MAX_ADDRESSES_FROM_RESOLVER():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  balancesOf(account: Address): BinaryOptionMarket__balancesOfResult {
    let result = super.call(
      "balancesOf",
      "balancesOf(address):(uint256,uint256)",
      [ethereum.Value.fromAddress(account)]
    );

    return new BinaryOptionMarket__balancesOfResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_balancesOf(
    account: Address
  ): ethereum.CallResult<BinaryOptionMarket__balancesOfResult> {
    let result = super.tryCall(
      "balancesOf",
      "balancesOf(address):(uint256,uint256)",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BinaryOptionMarket__balancesOfResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  bidOrRefundForPrice(
    bidSide: i32,
    priceSide: i32,
    price: BigInt,
    refund: boolean
  ): BigInt {
    let result = super.call(
      "bidOrRefundForPrice",
      "bidOrRefundForPrice(uint8,uint8,uint256,bool):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(bidSide)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(priceSide)),
        ethereum.Value.fromUnsignedBigInt(price),
        ethereum.Value.fromBoolean(refund)
      ]
    );

    return result[0].toBigInt();
  }

  try_bidOrRefundForPrice(
    bidSide: i32,
    priceSide: i32,
    price: BigInt,
    refund: boolean
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "bidOrRefundForPrice",
      "bidOrRefundForPrice(uint8,uint8,uint256,bool):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(bidSide)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(priceSide)),
        ethereum.Value.fromUnsignedBigInt(price),
        ethereum.Value.fromBoolean(refund)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  bidsOf(account: Address): BinaryOptionMarket__bidsOfResult {
    let result = super.call("bidsOf", "bidsOf(address):(uint256,uint256)", [
      ethereum.Value.fromAddress(account)
    ]);

    return new BinaryOptionMarket__bidsOfResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_bidsOf(
    account: Address
  ): ethereum.CallResult<BinaryOptionMarket__bidsOfResult> {
    let result = super.tryCall("bidsOf", "bidsOf(address):(uint256,uint256)", [
      ethereum.Value.fromAddress(account)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BinaryOptionMarket__bidsOfResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  canResolve(): boolean {
    let result = super.call("canResolve", "canResolve():(bool)", []);

    return result[0].toBoolean();
  }

  try_canResolve(): ethereum.CallResult<boolean> {
    let result = super.tryCall("canResolve", "canResolve():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  claimOptions(): BinaryOptionMarket__claimOptionsResult {
    let result = super.call(
      "claimOptions",
      "claimOptions():(uint256,uint256)",
      []
    );

    return new BinaryOptionMarket__claimOptionsResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_claimOptions(): ethereum.CallResult<
    BinaryOptionMarket__claimOptionsResult
  > {
    let result = super.tryCall(
      "claimOptions",
      "claimOptions():(uint256,uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BinaryOptionMarket__claimOptionsResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  claimableBalancesOf(
    account: Address
  ): BinaryOptionMarket__claimableBalancesOfResult {
    let result = super.call(
      "claimableBalancesOf",
      "claimableBalancesOf(address):(uint256,uint256)",
      [ethereum.Value.fromAddress(account)]
    );

    return new BinaryOptionMarket__claimableBalancesOfResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_claimableBalancesOf(
    account: Address
  ): ethereum.CallResult<BinaryOptionMarket__claimableBalancesOfResult> {
    let result = super.tryCall(
      "claimableBalancesOf",
      "claimableBalancesOf(address):(uint256,uint256)",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BinaryOptionMarket__claimableBalancesOfResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  creator(): Address {
    let result = super.call("creator", "creator():(address)", []);

    return result[0].toAddress();
  }

  try_creator(): ethereum.CallResult<Address> {
    let result = super.tryCall("creator", "creator():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  creatorLimits(): BinaryOptionMarket__creatorLimitsResult {
    let result = super.call(
      "creatorLimits",
      "creatorLimits():(uint256,uint256)",
      []
    );

    return new BinaryOptionMarket__creatorLimitsResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_creatorLimits(): ethereum.CallResult<
    BinaryOptionMarket__creatorLimitsResult
  > {
    let result = super.tryCall(
      "creatorLimits",
      "creatorLimits():(uint256,uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BinaryOptionMarket__creatorLimitsResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  deposited(): BigInt {
    let result = super.call("deposited", "deposited():(uint256)", []);

    return result[0].toBigInt();
  }

  try_deposited(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("deposited", "deposited():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  exercisableDeposits(): BigInt {
    let result = super.call(
      "exercisableDeposits",
      "exercisableDeposits():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_exercisableDeposits(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "exercisableDeposits",
      "exercisableDeposits():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  exerciseOptions(): BigInt {
    let result = super.call(
      "exerciseOptions",
      "exerciseOptions():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_exerciseOptions(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "exerciseOptions",
      "exerciseOptions():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  fees(): BinaryOptionMarket__feesResult {
    let result = super.call("fees", "fees():(uint256,uint256,uint256)", []);

    return new BinaryOptionMarket__feesResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt()
    );
  }

  try_fees(): ethereum.CallResult<BinaryOptionMarket__feesResult> {
    let result = super.tryCall("fees", "fees():(uint256,uint256,uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BinaryOptionMarket__feesResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt()
      )
    );
  }

  getResolverAddressesRequired(): Array<Bytes> {
    let result = super.call(
      "getResolverAddressesRequired",
      "getResolverAddressesRequired():(bytes32[24])",
      []
    );

    return result[0].toBytesArray();
  }

  try_getResolverAddressesRequired(): ethereum.CallResult<Array<Bytes>> {
    let result = super.tryCall(
      "getResolverAddressesRequired",
      "getResolverAddressesRequired():(bytes32[24])",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytesArray());
  }

  isResolverCached(_resolver: Address): boolean {
    let result = super.call(
      "isResolverCached",
      "isResolverCached(address):(bool)",
      [ethereum.Value.fromAddress(_resolver)]
    );

    return result[0].toBoolean();
  }

  try_isResolverCached(_resolver: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isResolverCached",
      "isResolverCached(address):(bool)",
      [ethereum.Value.fromAddress(_resolver)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  nominatedOwner(): Address {
    let result = super.call("nominatedOwner", "nominatedOwner():(address)", []);

    return result[0].toAddress();
  }

  try_nominatedOwner(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "nominatedOwner",
      "nominatedOwner():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  options(): BinaryOptionMarket__optionsResult {
    let result = super.call("options", "options():(address,address)", []);

    return new BinaryOptionMarket__optionsResult(
      result[0].toAddress(),
      result[1].toAddress()
    );
  }

  try_options(): ethereum.CallResult<BinaryOptionMarket__optionsResult> {
    let result = super.tryCall("options", "options():(address,address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BinaryOptionMarket__optionsResult(
        value[0].toAddress(),
        value[1].toAddress()
      )
    );
  }

  oracleDetails(): BinaryOptionMarket__oracleDetailsResult {
    let result = super.call(
      "oracleDetails",
      "oracleDetails():(bytes32,uint256,uint256)",
      []
    );

    return new BinaryOptionMarket__oracleDetailsResult(
      result[0].toBytes(),
      result[1].toBigInt(),
      result[2].toBigInt()
    );
  }

  try_oracleDetails(): ethereum.CallResult<
    BinaryOptionMarket__oracleDetailsResult
  > {
    let result = super.tryCall(
      "oracleDetails",
      "oracleDetails():(bytes32,uint256,uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BinaryOptionMarket__oracleDetailsResult(
        value[0].toBytes(),
        value[1].toBigInt(),
        value[2].toBigInt()
      )
    );
  }

  oraclePriceAndTimestamp(): BinaryOptionMarket__oraclePriceAndTimestampResult {
    let result = super.call(
      "oraclePriceAndTimestamp",
      "oraclePriceAndTimestamp():(uint256,uint256)",
      []
    );

    return new BinaryOptionMarket__oraclePriceAndTimestampResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_oraclePriceAndTimestamp(): ethereum.CallResult<
    BinaryOptionMarket__oraclePriceAndTimestampResult
  > {
    let result = super.tryCall(
      "oraclePriceAndTimestamp",
      "oraclePriceAndTimestamp():(uint256,uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BinaryOptionMarket__oraclePriceAndTimestampResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  phase(): i32 {
    let result = super.call("phase", "phase():(uint8)", []);

    return result[0].toI32();
  }

  try_phase(): ethereum.CallResult<i32> {
    let result = super.tryCall("phase", "phase():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  prices(): BinaryOptionMarket__pricesResult {
    let result = super.call("prices", "prices():(uint256,uint256)", []);

    return new BinaryOptionMarket__pricesResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_prices(): ethereum.CallResult<BinaryOptionMarket__pricesResult> {
    let result = super.tryCall("prices", "prices():(uint256,uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BinaryOptionMarket__pricesResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  pricesAfterBidOrRefund(
    side: i32,
    value: BigInt,
    refund: boolean
  ): BinaryOptionMarket__pricesAfterBidOrRefundResult {
    let result = super.call(
      "pricesAfterBidOrRefund",
      "pricesAfterBidOrRefund(uint8,uint256,bool):(uint256,uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(side)),
        ethereum.Value.fromUnsignedBigInt(value),
        ethereum.Value.fromBoolean(refund)
      ]
    );

    return new BinaryOptionMarket__pricesAfterBidOrRefundResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_pricesAfterBidOrRefund(
    side: i32,
    value: BigInt,
    refund: boolean
  ): ethereum.CallResult<BinaryOptionMarket__pricesAfterBidOrRefundResult> {
    let result = super.tryCall(
      "pricesAfterBidOrRefund",
      "pricesAfterBidOrRefund(uint8,uint256,bool):(uint256,uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(side)),
        ethereum.Value.fromUnsignedBigInt(value),
        ethereum.Value.fromBoolean(refund)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BinaryOptionMarket__pricesAfterBidOrRefundResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  refund(side: i32, value: BigInt): BigInt {
    let result = super.call("refund", "refund(uint8,uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(side)),
      ethereum.Value.fromUnsignedBigInt(value)
    ]);

    return result[0].toBigInt();
  }

  try_refund(side: i32, value: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall("refund", "refund(uint8,uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(side)),
      ethereum.Value.fromUnsignedBigInt(value)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  resolved(): boolean {
    let result = super.call("resolved", "resolved():(bool)", []);

    return result[0].toBoolean();
  }

  try_resolved(): ethereum.CallResult<boolean> {
    let result = super.tryCall("resolved", "resolved():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  resolver(): Address {
    let result = super.call("resolver", "resolver():(address)", []);

    return result[0].toAddress();
  }

  try_resolver(): ethereum.CallResult<Address> {
    let result = super.tryCall("resolver", "resolver():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  resolverAddressesRequired(param0: BigInt): Bytes {
    let result = super.call(
      "resolverAddressesRequired",
      "resolverAddressesRequired(uint256):(bytes32)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return result[0].toBytes();
  }

  try_resolverAddressesRequired(param0: BigInt): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "resolverAddressesRequired",
      "resolverAddressesRequired(uint256):(bytes32)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  result(): i32 {
    let result = super.call("result", "result():(uint8)", []);

    return result[0].toI32();
  }

  try_result(): ethereum.CallResult<i32> {
    let result = super.tryCall("result", "result():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  senderPriceAndExercisableDeposits(): BinaryOptionMarket__senderPriceAndExercisableDepositsResult {
    let result = super.call(
      "senderPriceAndExercisableDeposits",
      "senderPriceAndExercisableDeposits():(uint256,uint256)",
      []
    );

    return new BinaryOptionMarket__senderPriceAndExercisableDepositsResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_senderPriceAndExercisableDeposits(): ethereum.CallResult<
    BinaryOptionMarket__senderPriceAndExercisableDepositsResult
  > {
    let result = super.tryCall(
      "senderPriceAndExercisableDeposits",
      "senderPriceAndExercisableDeposits():(uint256,uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BinaryOptionMarket__senderPriceAndExercisableDepositsResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  times(): BinaryOptionMarket__timesResult {
    let result = super.call("times", "times():(uint256,uint256,uint256)", []);

    return new BinaryOptionMarket__timesResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt()
    );
  }

  try_times(): ethereum.CallResult<BinaryOptionMarket__timesResult> {
    let result = super.tryCall(
      "times",
      "times():(uint256,uint256,uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BinaryOptionMarket__timesResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt()
      )
    );
  }

  totalBids(): BinaryOptionMarket__totalBidsResult {
    let result = super.call("totalBids", "totalBids():(uint256,uint256)", []);

    return new BinaryOptionMarket__totalBidsResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_totalBids(): ethereum.CallResult<BinaryOptionMarket__totalBidsResult> {
    let result = super.tryCall(
      "totalBids",
      "totalBids():(uint256,uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BinaryOptionMarket__totalBidsResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  totalClaimableSupplies(): BinaryOptionMarket__totalClaimableSuppliesResult {
    let result = super.call(
      "totalClaimableSupplies",
      "totalClaimableSupplies():(uint256,uint256)",
      []
    );

    return new BinaryOptionMarket__totalClaimableSuppliesResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_totalClaimableSupplies(): ethereum.CallResult<
    BinaryOptionMarket__totalClaimableSuppliesResult
  > {
    let result = super.tryCall(
      "totalClaimableSupplies",
      "totalClaimableSupplies():(uint256,uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BinaryOptionMarket__totalClaimableSuppliesResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  totalSupplies(): BinaryOptionMarket__totalSuppliesResult {
    let result = super.call(
      "totalSupplies",
      "totalSupplies():(uint256,uint256)",
      []
    );

    return new BinaryOptionMarket__totalSuppliesResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_totalSupplies(): ethereum.CallResult<
    BinaryOptionMarket__totalSuppliesResult
  > {
    let result = super.tryCall(
      "totalSupplies",
      "totalSupplies():(uint256,uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BinaryOptionMarket__totalSuppliesResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _owner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _creator(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _creatorLimits(): Array<BigInt> {
    return this._call.inputValues[2].value.toBigIntArray();
  }

  get _oracleKey(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }

  get _strikePrice(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get _times(): Array<BigInt> {
    return this._call.inputValues[5].value.toBigIntArray();
  }

  get _bids(): Array<BigInt> {
    return this._call.inputValues[6].value.toBigIntArray();
  }

  get _fees(): Array<BigInt> {
    return this._call.inputValues[7].value.toBigIntArray();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AcceptOwnershipCall extends ethereum.Call {
  get inputs(): AcceptOwnershipCall__Inputs {
    return new AcceptOwnershipCall__Inputs(this);
  }

  get outputs(): AcceptOwnershipCall__Outputs {
    return new AcceptOwnershipCall__Outputs(this);
  }
}

export class AcceptOwnershipCall__Inputs {
  _call: AcceptOwnershipCall;

  constructor(call: AcceptOwnershipCall) {
    this._call = call;
  }
}

export class AcceptOwnershipCall__Outputs {
  _call: AcceptOwnershipCall;

  constructor(call: AcceptOwnershipCall) {
    this._call = call;
  }
}

export class BidCall extends ethereum.Call {
  get inputs(): BidCall__Inputs {
    return new BidCall__Inputs(this);
  }

  get outputs(): BidCall__Outputs {
    return new BidCall__Outputs(this);
  }
}

export class BidCall__Inputs {
  _call: BidCall;

  constructor(call: BidCall) {
    this._call = call;
  }

  get side(): i32 {
    return this._call.inputValues[0].value.toI32();
  }

  get value(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class BidCall__Outputs {
  _call: BidCall;

  constructor(call: BidCall) {
    this._call = call;
  }
}

export class ClaimOptionsCall extends ethereum.Call {
  get inputs(): ClaimOptionsCall__Inputs {
    return new ClaimOptionsCall__Inputs(this);
  }

  get outputs(): ClaimOptionsCall__Outputs {
    return new ClaimOptionsCall__Outputs(this);
  }
}

export class ClaimOptionsCall__Inputs {
  _call: ClaimOptionsCall;

  constructor(call: ClaimOptionsCall) {
    this._call = call;
  }
}

export class ClaimOptionsCall__Outputs {
  _call: ClaimOptionsCall;

  constructor(call: ClaimOptionsCall) {
    this._call = call;
  }

  get longClaimed(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get shortClaimed(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class ExerciseOptionsCall extends ethereum.Call {
  get inputs(): ExerciseOptionsCall__Inputs {
    return new ExerciseOptionsCall__Inputs(this);
  }

  get outputs(): ExerciseOptionsCall__Outputs {
    return new ExerciseOptionsCall__Outputs(this);
  }
}

export class ExerciseOptionsCall__Inputs {
  _call: ExerciseOptionsCall;

  constructor(call: ExerciseOptionsCall) {
    this._call = call;
  }
}

export class ExerciseOptionsCall__Outputs {
  _call: ExerciseOptionsCall;

  constructor(call: ExerciseOptionsCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class ExpireCall extends ethereum.Call {
  get inputs(): ExpireCall__Inputs {
    return new ExpireCall__Inputs(this);
  }

  get outputs(): ExpireCall__Outputs {
    return new ExpireCall__Outputs(this);
  }
}

export class ExpireCall__Inputs {
  _call: ExpireCall;

  constructor(call: ExpireCall) {
    this._call = call;
  }

  get beneficiary(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ExpireCall__Outputs {
  _call: ExpireCall;

  constructor(call: ExpireCall) {
    this._call = call;
  }
}

export class NominateNewOwnerCall extends ethereum.Call {
  get inputs(): NominateNewOwnerCall__Inputs {
    return new NominateNewOwnerCall__Inputs(this);
  }

  get outputs(): NominateNewOwnerCall__Outputs {
    return new NominateNewOwnerCall__Outputs(this);
  }
}

export class NominateNewOwnerCall__Inputs {
  _call: NominateNewOwnerCall;

  constructor(call: NominateNewOwnerCall) {
    this._call = call;
  }

  get _owner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class NominateNewOwnerCall__Outputs {
  _call: NominateNewOwnerCall;

  constructor(call: NominateNewOwnerCall) {
    this._call = call;
  }
}

export class RefundCall extends ethereum.Call {
  get inputs(): RefundCall__Inputs {
    return new RefundCall__Inputs(this);
  }

  get outputs(): RefundCall__Outputs {
    return new RefundCall__Outputs(this);
  }
}

export class RefundCall__Inputs {
  _call: RefundCall;

  constructor(call: RefundCall) {
    this._call = call;
  }

  get side(): i32 {
    return this._call.inputValues[0].value.toI32();
  }

  get value(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class RefundCall__Outputs {
  _call: RefundCall;

  constructor(call: RefundCall) {
    this._call = call;
  }

  get refundMinusFee(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class ResolveCall extends ethereum.Call {
  get inputs(): ResolveCall__Inputs {
    return new ResolveCall__Inputs(this);
  }

  get outputs(): ResolveCall__Outputs {
    return new ResolveCall__Outputs(this);
  }
}

export class ResolveCall__Inputs {
  _call: ResolveCall;

  constructor(call: ResolveCall) {
    this._call = call;
  }
}

export class ResolveCall__Outputs {
  _call: ResolveCall;

  constructor(call: ResolveCall) {
    this._call = call;
  }
}

export class SetResolverAndSyncCacheCall extends ethereum.Call {
  get inputs(): SetResolverAndSyncCacheCall__Inputs {
    return new SetResolverAndSyncCacheCall__Inputs(this);
  }

  get outputs(): SetResolverAndSyncCacheCall__Outputs {
    return new SetResolverAndSyncCacheCall__Outputs(this);
  }
}

export class SetResolverAndSyncCacheCall__Inputs {
  _call: SetResolverAndSyncCacheCall;

  constructor(call: SetResolverAndSyncCacheCall) {
    this._call = call;
  }

  get _resolver(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetResolverAndSyncCacheCall__Outputs {
  _call: SetResolverAndSyncCacheCall;

  constructor(call: SetResolverAndSyncCacheCall) {
    this._call = call;
  }
}
